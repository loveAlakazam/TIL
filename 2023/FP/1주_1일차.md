# 함수형프로그래밍

f(x)

람다식

1. 멱등성

추상화로 심플함을 증명

2. 사이드이펙트를 없애자.

- 순수함수: 외부환경에 노출되지 않고 변화되지 않은 함수

```ts
const init = 0; // 외부에서 변할 수 있다.

const add = (number) => {
  return number + init;
};

add(3);
```

- 순수함수

init값을 외부에 노출함으로써 변할 수 있다. 기대했던 함수의 결과값이 바뀜

```ts
const init = 0; // 외부에서 변할 수 있다.

const add = (init, number) => {
  // 인자를 받아서 안정한 값을 리턴. - 외부에 의존하지 않고 결과를 낸다.
  return number + init;
};

add(3, init);
add(3); // nan
```

- bad
  - name, `console.log()` 는 외부에 의존하며 외부의 요인이다.
  - 우리가 구현한 함수의 구현체가 아니다.

```ts
const name = 'jun';

const greet = () => {
  console.log(name);
};

greet();
```

- good

```ts
const name = 'jun';

const greet = (name, log) => {
  log(name);
};

console.log(name, console.log);
console.log(name, console.error); // 인자값으로 함수가 들어있음(console.log)
```

- 변화를 시키지말자 (no mutation)

```ts
const fruits = ['사과', '귤', '포도'];

const head = (arr) => {
  return arr.shift();
};

head(fruists); // 사과
```

인자로 들어온 원본배열을 변환 -> 첫번째로 들어온 값이 나옴.

```ts

```

원본배열을 수정하지 않는다.

이미 약속된 구현체

함수형프로그래밍 패러다임을 지원하는 언어

맵함수는 언제나 똑같은 일을한다.

새로운 배열을 리턴받아서 새로운배열을 화면에 출력

기존에 사용하고 있는 시스템에 영향을 끼치지 않는다.

> 고차함수: 함수를 인자로 받는다 / 함수를 리턴한다.

- 함수는 값이다. => 함수를 값으로 다룰 수 있다.

- 맵함수도 고차함수다 : 함수를 인자로 들어있다.

```ts
const fruits = ['사과', '배', '포도'];
const ilieSTG = (fruits) => {
  return fruit === '포도' ? '딸기' : fruit;
};

ilieSTG(ftuis);
```

no 사이드이펙트

- 개발자는 사이드이펙트를 생성한다
  - 사이드이펙트 : 알람 / 유저 인터렉션 구현 => 외부에 영향을 주는 것 (메시지 출력, 변수값 수정, 이메일을 보내는 것)

패러다임 = 룰 + 마인드셋(사고방식) + 철학

> 함수형 프로그래밍

- OOP(Object oriented programming)

  - 메시징 을 사용하자.
  - messaging oriented programming

- 일관적인 방법으로 모듈화
- 다형성
- 현실세계로 모델링

같은 메시지를 전달

현실세계를 프로그래밍세계로 전달할때 oop를 사용...

- 메시징?
- 현실세계로 모델링

<br>

함수형프로그래밍 패러다임

- 일관적인 방법으로 모듈화
- 인풋과 아웃풋에만 의존 `output= f(input)`
- 수학의 관점으로 사고

oop와 fp는 다른것처럼 보이겠지만, 실제로는 비슷하다 (관점이 약간 다르겠지만)

유지보수가 쉽고 코드 생산성이 높고 신뢰가능
변경이 쉬운 소프트웨어
우리, 팀이 원하는 의사결정
새로운 기술의 도입은 새로운 책임

실용주의 프로그래밍

---

사이드 이펙트를 없애자

룰에 맞게 사고하게되고 여러분의 프로그래밍의 철학이 될 수 있다.

references를 하나씩 훑어보면서... 함수형 프로그래밍에 익숙해지기

언제나 똑같은 일을 할수 있도록 구현하는 것.?

oop와 fp를 같이 쓸 수 있다.

---

라이브 코딩

# map / filter / reduce 고차함수 구현하기

## 예제 1

- 절차지향

```ts
const arr = [1, 2, 3, 4, 5];

// 1. 홀수만 거르기
// 2. 걸러진 원소에 곱하기 2
// 3. 모두 다 더하기

let sum = 0;
for (const e of arr) {
  if (e % 2 === 1) {
    const ne = e * 2;
    sum += ne;
  }
}

console.log(sum); // 18
```

- 함수형
  - filter을 사용

```ts
const arr = [1, 2, 3, 4, 5];

// 1. 홀수만 거르기
// 2. 걸러진 원소에 곱하기 2
// 3. 모두 다 더하기

const arr = [1, 2, 3, 4, 5];

const sum = arr
  .filter((e: number) => e % 2 === 1) // number
  .map((e: number) => e * 2) // unknown
  .reduce((prev, curr) => prev + curr);
console.log(sum);
```

- map

```ts
// 배열 순회
// map: 배열을 순회하면서 함수를 적용해서 새로운 결과 값을 담은 배열을 리턴
//  func: (e) => value

const map = (func, iter) => {
  const result = [];

  for (const e of iter) {
    result.push(func(e));
  }

  return result;
};

console.log(map(e)=> e * 2, arr)
```

- filter

```ts
// 배열을 순회하면서 func의 truthy한 값(조건에 맞는값)만을 배열에 담아
// func (e) => truthy | falsy

const filter = (f, t) => {
  const result = [];

  for (const e of iter) {
    if (f(e)) {
      result.push(e);
    }
  }

  return result;
};
```

- reduce
  - map/filter : 새로운 배열을 리턴
  - 값을 쪼개는 함수

```ts
// reduce: 배열을 순회하면서 func을 반복적용해서 새로운 결과값을 얻어낸다(쪼개는함수)
// func(acc, e) => acc
// acc: 반복적용해서 새로운 결과값이고 그 결과값을 저장하는 인자
// 이전값을 던지면서 새로운 값을 얻음.
const reduce = (func, acc, iter) => {
  for (const e of iter) {
    acc = func(acc, e);
  }
  return acc;
};

console.log(reduce((prev, curr) => prev + curr, 0, arr)); // acc인자 초기값을 0 으로한다.
```

- reduce 업그레이드: iterable protocol
  - 넣어주지않아도 넣을 수 있다.
  - 순회가능한 자료형은 해당 프로토콜을 따라야한다.
  - [symbol.iterator]() => iterator
  - iterator.next()

발전코드 - 객체배열을 이런식으로 구현되어있다.

```ts
const reduce = (func, acc, iter) => {
  if (iter === undefined) {
    iter = acc[Symbol.iterator]();
    acc = iter.next().value;
  }

  for (const e of iter) {
    acc = func(acc, e);
  }

  return acc;
};
console.log(reduce((prev, curr) => prev + curr, arr));
```

```ts
const iterator = arr[Symbol.iterator]();

console.log(iterator.next().value);
```

- 배열객체가 있다면, Symbol.iterator 로 이미 구현이 되어있다.
- 값을 직접 생성할 수 있다

# 함수의 합성

```ts
// 순회가능한 객체를 받아서 함수의 파이프라인을 타고 최종결과값을
// 최종결과값을 리턴한다.(쪼개서 결과를 리턴하는 reduce함수와 유사)
const arr = [1, 2, 3, 4, 5];

const sum = reduce(
  (prev, curr) => prev + curr,
  map(
    (e) => e * 2,
    filter((e: nubmer) => e % 2 === 1)
  )
); // 기괴하다... 합성함수
```

함수의 합성을 위한 파이프

- rxJS 의 파이프와 유사하다.

```ts
pipe(
  arr,
  (arr) => filter((e) => e % 2 === 1, arr),
  (arr) => map((e) => e * 2, arr),
  (arr) => reduce((prev, curr) => prev + curr, arr),
  (result) => console.log(result)
);
```

- reduce를 사용 => reduce 의 functions...
  - 재귀
    파이프원리

```ts
const pipe = (iter, ...functions) =>
  reduce(
    (prev, curr) => func(prev), // prev에 functions를 가리킨다.
    iter,
    functions
  );
```

- pipe 함수를 더 간단히 나타낼 수 있을까..?

  - 커링을 써보면 어때? 아래처럼!(파이프+커링)

```ts
pipe(
  arr,
  filter((e) => e % 2 === 1),
  map((e) => e * 2),
  reduce((prev, curr) => prev + curr),
  console.log // 이전에 머금된값이 reduce에 있기때문에
);
```

# 커링을 이용해서 로직을 더 간단하게 나타내기

curring, 모나드

어떻게 로직을 간단하게 변경되는지?

## 커링함수

```ts
const add = (a, b) => a + b;
console.log(add(1, 2)); //정상
console.log(add(1)); // 하나의 인자만 받을경우?(NaN발생)
```

add라는 함수의 인자가 다들어오지않는데도 함수실행하는데 에러를 낼 수 있다.

커링은
add 1이 들어왓을때 미루고

다른 인자를 받을 때까지 기다린다.
두번째 인자가 생길때 4를 리턴하도록 한다.

함수를 인자로 받아서 새로운 함수를 리턴.

필수조건이 충족되지 않으면 실행을 미룬다.

커링은 함수들을 먼저 합성해놓을 수 있다

```ts
const curry =
  (func) =>
  (a, ...args) =>
    args.length > 0 ? func(a, ...args) : (...args) => func(a, ...args);

const add = curry((a, b) => a + b);


add(a:1,args:3)// 정상동작
add(a:1) // 미룸

add((a:1)(args: 3)) // 다시 받아서 동작됨.
```

<br>

```ts
const peope = [
  { name: 'a', age: 10, city: 'seoul' },
  { name: 'b', age: 21, city: 'seoul' },
  { name: 'c', age: 20, city: 'busan' },
  { name: 'jay', age: 15, city: 'la' },
  { name: 'john', age: 30, city: 'london' },
];

// 서울에 사는 사람들만 추출
pipe(
  people,
  filter((person) => person.city === 'seoul'),
  map((person) => person.name),
  console.log
);

// age의 총합
const add = (a, b) => a + b;
pipe(
  people,
  filter((person) => person.city === 'seoul'),
  map((person) => person.age),
  reduce(add),
  //   reduce((prev, curr) => prev + curr),
  console.log
);

// 첫글자에 j가 나오는사람 추출
// 나이가 20살 이하
pipe(
  people,
  filter((p) => p.name.startsWith('j')), // 맨앞글자가 j
  filter((p) => p.age <= 20), //20살이하
  map((p) => p.city), //사는 도시 추출
  console.log
);
```

- 데이터베이스의 select쿼리문도 이와 같다...(쿼리를 함수로 바라보다..)

- 함수가 값이기때문에 -> 얼마든지 함수를 합성하고, 조합하고 생성할 수 잇음.
- 이미약속된 함수를 사용하기때문에,

- 사이드이펙트: 비즈니스로직를 만든다.
- 함수형패러다임에 익숙하지않으면 도저히 무슨말인지 모름. - 실용주의 프로그래밍 - 부단한 노력이필요.
- 무작정쓰는것은 좋지않다.

- 함수를 직접 디버깅해서 콘솔에도 출력해보고 스스로 원리를 차근차근 깨우쳐보는걸 추천한다.

---

# 지연평가

- 필터까지는
- 100만번 메모리할당에 늘어난다.

> 지연평가

- 평가의 시점을 미루고-> 실제로 값을 쪼개는 시점에 데이터를 평가한다.

> generator

- ex. range
- 이터레이터를 리턴하는 함수.

```ts
const range = function* (limit) => {
let i = -1
while(++i < limit){
    yield i;
}
}

```

- 제너레이터를 통해서 지연평가를 할 수 있다.

```ts
const lmap = curry(function* (func1, iter) {
  for (const e of iter) {
    yield func(e);
  }
});
```

- 지연평가 필터

```ts
const lfilter = curry(function* (func, iter) {
  for (const e of iter) {
    if (func(e)) {
      yield e;
    }
  }
};)
```

- 배열을 한번만 순회하도록( 횡단에서 종단으로 처리)
- 스트림의 동작방식

---

## 실무에셔의 함수형프로그래밍

# sql injection prevention 미들웨어 구현

- 미들웨어: 함수, 인터셉터
- fxts

```ts

```
