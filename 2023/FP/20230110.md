# 함수형 프로그래밍 스스로 학습해보기

- [Typescript와 fp-ts 라이브러리를 활용한 함수형 프로그래밍 가이드](https://jbl428.github.io/functional-programming/what-is-fp/index.html)

## 함수형 프로그래밍 이란

> `함수형 프로그래밍은 순수함수, 수학적인 함수를 사용하는 프로그래밍` 을 의미한다.
>
> `같은 입력에 항상 같은 결과를 내는 부작용없는 절차`이다.
>
> - `부작용 없는 절차`의 부작용?
>
>   => 함수가 값을 반환하는 작업 외의 모든 것
>
> - 함수형 프로그래밍의 목적은 무엇일까?
>
>   => 수학적 모델을 사용해서 **`시스템의 복잡성`**을 조정하고 **`코드의 속성`**과 **`리팩토링의 편의성`**에 중점을 두기 위해서이다.
>
>   => 함수형 프로그래밍은 구체적인 코드구현 보다 코드의 속성에 집중한다.

<br>

## 순수함수 만 사용하는 프로그램이 갖는 구조가 무엇일까?

- 파이프 라인의 형태로 이루어져 있다.

```ts
const program = pipe( input, f1, f2, f3, ... )
```

여기서 f1, f2, f3 는 모두 순수함수들이다.

input은 첫번째 함수인 f1으로 전달되고

f1의 결과는 두번째 함수 f2로 전달된다.

f2가 반환하는 값은 세번째함수인 f3로 전달되고, 이후에도 같은 방식으로 진행된다.

### 예제

```ts
// 입력
const xs: Array<number> = [1, 2, 3];

// 수정
const double = (n: number): number => n * 2;

// 결과: xs의 각요소들이 2배가 된 배열을 얻는다.
const ys: Array<number> = [];
for (let i = 0; i <= xs.length; i++) {
  ys.push(dobule(xs[i]));
}
```

> Q. for 반복문보다 Array의 map이 왜 더 함수형일까?
>
> A. 먼저 말하자면 **결과물에 대한 확신** 이 큰 차이이다.

- for 반복문

  > - for 반복문은 **유연성**을 제공하며, 유연성은 **값 변경을 가능**하게 한다. 그러나 이 유연성으로 인해 값이 수정되면서 에러를 유발시킬 수 있다. 에러를 유발된다는 것은 **값에 대한 확신이 줄게** 만든다.
  >
  > - 시작위치: `let i =0`
  > - 반복조건: `i < xs.length`
  > - 반복제어: `i++`

<br>

- `map` 을 이용한 코드

```ts
// 입력
const xs: Array<number> = [1, 2, 3];

// 수정
const double = (n: number): number => n * 2;

// 결과: xs의 각요소들이 2배가 된 배열을 얻는다.
const ys: Array<number> = xs.map(double);
```

map은 for반복문에 비해 유연성이 적지만 확신을 제공한다.

- 입력 배열의 모든요소에 대해 처리된다.
- 결과 배열의 크기는 입력배열의 크기와 동일하다.

---

> 함수형 프로그래밍은 참조투명성과 합성 를 기반으로 한다.

# 참조투명성

> **정의**
>
> 표현식이 평가되는 결과로 바꿔도 프로그래밍의 동작이 변하지 않는다면 해당 표현식은 참조에 투명하다.

<br>

> **왜 중요할까?**
>
> - **지역적인 코드분석**: 코드를 이해하기 위해 외부 문맥을 알 필요가 없다.
>
> - **코드수정 용이** : 시스템의 동작을 변경하지 않고 코드를 수정할 수 있다.
>   - 수정에 필요한 인지부하를 상당히 줄일 수 있다.
>   - 참조투명성이 없는 표현식(참조 투명하지 않은 표현식) 수정이 어렵기 때문.

<br>

### 예제

```ts
const double = (n: number): number => n * 2;

const x = double(2); // 4
const y = double(2); // 4
```

`double(2)` 표현식은 결과인 4로 변경할 수 있기에 참조투명성을 갖고 있다.

따라서 코드는 아래와 같이 바꿀 수 있다.

```ts
const x = 4;
const y = 4;
```

<br>

그러나 모든 표현식이 항상 참조투명성을 갖지 않는다.

**`참조투명성`은 에러를 발생시키지 않으며, 불변의 자료구조를 사용해야 된다.**

<br>

### 참조투명성을 갖지 않은 예 1 - 에러발생

```ts
const inverse = (n: number): number => {
  if (n === 0) {
    throw new Error('cannot divide by zero');
  }

  return 1 / n;
};

const x = inverse(0) + 1; // 에러발생
```

<br>

### 참조투명성을 갖지 않은 예 2 - 자료구조가 바뀌는 경우

```ts
const xs = [1, 2, 3];

const append = (xs: Array<number>): void => {
  xs.push(4); // xs: [1,2,3,4]
};

append(xs);

const ys = xs; // xs는 초기값([1,2,3])으로 대체할 수 없다.
```

<br>

---

# 합성

- 특정한 작업을 수행하는 작은 단위의 코드를 합성해 크고 복잡한 단위로 구성한다.

- 가장 작은 것에서 가장 큰 것으로 합성하는 패턴의 예

  - 두개이상의 기본타입값을 합성(숫자나 문자열)
  - 두개이상의 함수를 합성
  - 전체 프로그램의 합성 (모듈화 프로그래밍)
    - 모듈화 프로그래밍: 더 작은 프로그램을 붙여 큰 프로그램을 만드는 과정을 의미한다.

- combinator pattern

```
사물들을 조합한다는 개념을 중심으로 하여 라이브러리를 만드는 방법


어떤 타입 T와 T의 기본값들
그리고 T의 값들을 다양한 방법으로 조합하여
더 복잡한 값을 만드는 combinator가 있다.



combinator: Thing -> (New) Thing


combinator의 목적은 이미 정의된 어떤 것으로부터 새로운 어떤 것을 만드는 것을 의미한다.

combinator의 출력인 '새로운 어떤것'은 다른 프로그램이나 'combinator'로 전달할 수 있어서 '조합적 폭발'을 얻을 수 있다.
```

### 예제

```ts
const double = (n: number): number => n * 2;

console.log(pipe(2, double, double, double)); // 16
```

따라서 함수형 모듈에서는 다음과 같은 일반적인 형태를 볼 수 있다.

- 타입 T에 대한 model
- 타입 T의 primitives
- primitives 를 더 큰 구조로 조합하기 위한 combinators

---

# 순수함수

- [참고 자료](https://jbl428.github.io/functional-programming/pure-and-partial-functions/index.html)

- 정의

> 같은 입력창에 항상 같은 결과를 내는 관찰 가능한 부작용없는 절차.
