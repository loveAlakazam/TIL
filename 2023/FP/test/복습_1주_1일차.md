# 1일차 - 함수형 프로그래밍, 실무에서 사용할 수 있나요?

- 발표자 및 멘토: 최준 / 마플 백엔드 개발자

## 함수형 프로그래밍 컨셉

프리스턴 대학교 수학논문에서는 `1+1=2` 라는 것을 복잡하고 추상된 증명을 통해서 입증했다.

우리가 수학에서 배운 `y=f(x)`를 프로그래밍으로 나타내는 것이다.
여기서 y는 output을, x는 input이다.

함수형프로그래밍의 근본적인 목적은

> - 사이드 이펙트는 존재하지 않는다. (No Side-Effect)
> - 순수함수( Pure Function)
> - 초기값의 구조가 변화되지 않아야한다.( No Mutation )

<br>

조금더 구체적인 함수형 프로그램의 예가 무엇일까?

> - map 함수
> - filter 함수
> - reduce 함수
> - 람다식
> - 커링
> - 모나드

<br>

어려워보이고 낯설겠지만

프로그래밍 언어 상관없이 함수형프로그래밍을 할 수 있다.

그리고 타입스크립트(자바스크립트)가 함수형프로그래밍이 가능한 이유는 함수를 값처럼 사용할 수 있기 때문이다.

<br>

> 사이드 이펙트(side effect)

사이드 이펙트는 크게보면 '변화'를 일으키는 것이라고 본다.

특히 애플리케이션에서도, API에서도 수없이 많은 변화가 일어난다.

우리는 사이드 이펙트를 만들어내고 있다.

필자의 실생활을 꺼내서, 조금 더 구체적으로 설명해보겠다.

```
필자는 커피를 너무 좋아한다. 하루에 한잔은 꼭 먹어야한다.

필자는 오슬랑 커피를 '패스오더'앱에서 주문을 한다. 결제수단중 카카오페이 를 선택했다.

그러면 갑자기 카카오페이 결제화면으로 이동하여 카카오페이에서 결제내역을 확인해달라는 요청이뜬다.
```

위의 예에서는 '패스오더'앱에서 '카카오페이 결제화면'으로 이동되는 현상과 같이

'송금이 완료되면 송금완료했다고 카톡메시지를 받는 것'과 같이

외부요인에 의해 메시지를 출력하거나, 변수값이 변경되는 것 등등등

**외부요인으로 부터 변화가 발생하는 현상**을 사이드 이펙트라고 한다.

<br>

> 순수함수

- 외부요인이 없는 함수
- 외부에 의존하지 않고 결과를 내는 함수를 의미한다.
- Higher Order Function의 원리를 갖는 함수

> Higher Order Function : 함수를 다른함수의 인자의 input으로 하여 해당함수내에서 결과를 내도록하는 것

<br>

> 프로그램의 구조상의 변화(Mutation)

배열의 초기값이 아예 변경되버리는 현상이 프로그램의 구조상의 변화의 예시중 하나이다.

초기값이 변해버린 예를 더 구체화시키자면, `push`, `pop`, `shft` 함수 등을 사용해서 배열요소의 개수가 변한다던가

아니면 특정 배열의 값을 바꾸는 걸 의미한다.

- 함수형 프로그래밍이 아닌 예1: 배열의 요소 개수가 변한 경우

```ts
const fruits = ['사과', '오렌지', '포도'];

const firstFruit = (arr) => {
    return arr.shift();
}

const firstFruit(fruits);
// firstFruit: '사과'
// fruits = ['오렌지', '포도']

```

초기의 Input인 `fruits` 는 `['사과', '오렌지', '포도']` 인데

firstFruit() 함수를 수행한 이후로부터 `fruits`가 `['오렌지', '포도']` 로 바뀌었으며

이러한 값의 변화가 사이드이펙트에 해당한다.

즉, 함수형프로그래밍은 input 원본값도 변화를 주면 안된다.

- 함수형 프로그래밍이 아닌 예2: 배열의 값 자체를 변화시켜버림

---

## 객체지향의 패러다임과 함수형 프로그래밍의 패러다임

### 객체지향의 패러다임

- Messaging 에 포커스되어있다.
- 현실세계를 모델링 : 객체를 통해서 프로그램에서 현실세계를 나타내는 것이다.

### 함수형프로그래밍의 패러다임

- 인풋과 아웃풋에만 의존한다. `output = f(input)`
- 수학적 관점으로 생각한다.

### 실용주의 프로그래밍

객체지향 + 함수형프로그래밍 을 둘다 적용하는게 실용주의!

요즘 실용주의 프로그래밍을 추구하고있다.

- 유지보수가 쉽고 생산성이 높고 신뢰가능한 프로그램

> 그러나 우리가 이 패러다임을 제대로 알고 적용하지 않는다면, 아무리 함수형프로그래밍 패러다임에 적용한 코드여도 똥을 쌀 수 있다. (과거의 코드는 똥이 될 가능성이 높다.) 💩

---

## 고차함수와 원리에 대해 알아보자

### 1. map

### 2. filter

- 배열을 순회하면서 조건에 맞는 값을 새로운 배열에 담아서 리턴한다.
- 초기의 배열의 값은 보존되어있다. (사이드 이펙트가 존재하지 않은 순수함수이다.)

```ts
const filter = (func, iter) => {
  const result = [];

  for (const e of iter) {
    if (f(e)) {
      result.push(e);
    }
  }

  return result;
};
```

### 3. reduce

- `map`, `filter` 수행하게되면 새로운 배열을 리턴한다.
- 반면 `reduce`는 값을 배열을 쪼개서 수행하는 함수이다.

```ts
const reduce = (func, acc, iter) => {
  for (const e of iter) {
    acc = func(acc, e);
  }

  return acc;
};
```

acc는 이전단계에서 반복적용해서 얻은 결과값들을 저장한다.

이전값을 던지면서 새로운 값을 얻는 것이다.

### 4. 함수의 합성

```ts
// 순회가능한 객체를 받아서 함수의 파이프라인을 타고 최종결과값을
// 최종결과값을 리턴한다.(쪼개서 결과를 리턴하는 reduce함수와 유사)
const arr = [1, 2, 3, 4, 5];

const sum = reduce(
  (prev, curr) => prev + curr,
  map(
    (e) => e * 2,
    filter((e: nubmer) => e % 2 === 1)
  )
);
```

- h(g(f(x)))을 프로그래밍으로 나타낸 것이다.
- reduce함수안에 map함수가 있고, map은 각 원소 요소값을 2배로하는 함수를 내포해있고, 이후에 홀수인 요소들만을 갖도록 하는 filter함수가 있다...

> pipe()

- 합성함수를 이해하기 쉽게 일직선 순으로 구성해놓은 함수이다.

```ts
const result = pipe(input, func1, func2, func3);
```

- y1= func1(input)
- y2 = func2(y1)
- result = func3(y2)

### 5. Curring

> 함수의 Input 인자 전체를 받지 못했다면 **모든인자를 받을 때까지 실행을 미루고**, **모든 인자를 받으면 실행하여 Output을 리턴하는 함수**
>
> 필수조건이 만족하지 않으면 실행을 미룬다는 것이다. 여기서 필수조건은 '모든 인자를 받아야한다' 이다.
>
> Curring은 함수들을 합성시킬 수 있다.

```ts
const add = (a, b) => a + b;

// 인자2개 모두받을 때 => 함수 실행하여 결과값 리턴받음 (3)
console.log(add(1, 2));
```

- curry 코드 예제

- curry 구현코드

```ts
// 과정1. 함수를 func 인자에 넣는다.
// 과정2. a를 포함한, args에 함수의 인자가 1개이상이라면 함수를 수행
// 과정3. 과정2의 결과값을, 다음 함수이자 재귀함수 func의 인자a로 보내어 결과값을 리턴
const curry = (func)
    => (a, ...args)
        => args.length > 0 ? func(a, ...args) : (..args)
            => func(a,...args);


// (a,b) => a+b 가 익명함수이며 이 함수를 func인자에 매핑한것이다.
const add = curry( (a,b) => a+b);

console.log(add(a:1, args: 3)); // 두개인자 전체이므로 수행 -> 4 출력
console.log(add(a:1)); // 인자 한개이므로 수행을 미룸 -> NaN
console.log(add((a:1)(args:3))); // 드디어 다른 인자를 받았으니 다시 수행 -> 4출력
```

<br>

### Pipe + Curring

> 파이프 함수와 커링을 사용하여 여러개의 합성함수를 가독성있고, 순차적으로 나타낼 수 있다.

```ts
pipe(
  arr,
  filter((e: number) => e % 2 === 1), // arr 중 홀수인 요소들만을 추출하고
  map((e: number) => e * 2), // 각요소의 값들을 2배로 하고
  reduce((prev, curr) => prev + curr), // 요소의 합을 구한다.
  console.log // 결과를 출력한다.
);
```

이전에 머금은 값을 reduce에 있기 때문에...?

---

## 지연평가

> 평가의 시점을 미루고, 실제로 값을 쪼개는 시점에서 데이터를 평가하는 것을 의미한다.
>
> 예를들어, generator, range() 가 해당한다.
> 데이터의 입/출력을 담당하는 스트림(stream)의 원리도 지연평가를 사용한다.
> 여러개의 데이터를 처리하는데 있어서 가로방향(횡단)이 아닌 세로방향(종단)으로 처리한다.
> -> 여기서 종단으로 처리하게되면 한번의 루프만으로도 대용량의 데이터들을 처리를 할 수 있음을 의미한다.

- 100만개의 데이터를 처리하려면 메모리 공간도 채워질뿐더러 성능이 저하될 수 있다.
- 그런데 100만건, 또는 그 이상의 대용량데이터를 빠르게 처리하는데 어떤 원리가 사용되는 걸까?

> 제너레이터를 통해서 지연평가가 가능하다.

> 지연평가 필터를 만들어보자

> 지연평가 Map을 만들어보자.

---

## 함수형프로그래밍이 실무에서 어떻게 적용되나요?

- 멘토님의 경험에서는 SQL Injection을 막는 미들웨어를 작성할 때 함수형프로그래밍을 사용했다고 말했다.

- 마플에서 개발한 [FxTs](https://fxts.dev/) 라이브러리를 활용했다고 한다.

---

## 오늘 내가 얻은 것

함수형 프로그래밍 내용을 전부다 이해하기는 어려웠지만 그래도 끝까지 강의를 들으려고 집중했다.

함수형프로그래밍과 객체지향프로그래밍은 달라보여도 관점을 수학적으로 보느냐와 실생활을 보느냐의 차이일뿐. 본질은 같다. input이 주어지면 함수를 통해서 output을 제공하듯...

함수형프로그래밍이 수학의 함수에서 비롯됐고, 제대로 의미를 알게된다면 효율적이고, 간결하면서 가독성이 있는 코드가 될 수 있다고 생각했다. 코드를 보면서 저렇게도 짤수 있구나 라는 감탄이 나올 수 밖에 없었다.

커링(curring)이라는 개념이 생소했는데 이번 세션을 통해서 커링을 처음 알게되었다.

조금더 공부를 해봐야겠다고 생각했다. 그런데 단순히 이론만 알기보다는 실제 경험을 해봐야 함수형프로그래밍을 모를때와 알 때의 차이를 확실히 느낄 수 있을 것 같았다. 약간 지식을 수용하기에 있어서 진입장벽이 높긴하지만, 여러가지의 합성함수를 코드로 나타냄으로써 사이드이펙트 없이 빠르게 수행하는 게 너무 좋았다.

개발자들도 다 과거의 코드가 언젠간 똥이 될 수있다는 것과, 내가 똥싸고 내가 싼똥을 치우면서 성장을 한다는게 위로가 되었다.

---

# 참고자료

## 🥹 멘토님이 추천해준 함수형프로그래밍 자료

## 😇 착한 사마리아인과 같은 수강생이 공유해준 자료

- [지연평가를 이용한 성능개선](https://armadillo-dev.github.io/javascript/whit-is-lazy-evaluation/)

나도 저렇게 깊이 생각해본 것을, 독자의 입장을 고려해서 어려운 개념을 글로 설득력있게 설명한 개발포스팅을 쓰고싶다...😭

## 😎 내가 구글링해서 찾아본 자료

- [Typescript와 fp-ts 라이브러리를 활용한 함수형 프로그래밍](https://jbl428.github.io/functional-programming/monoid-modeling/index.html)

- [teo.log - 다시쓰는 함수형 프로그래밍](https://velog.io/@teo/functional-programming)
